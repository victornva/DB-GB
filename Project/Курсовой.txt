------------------------------------------------------------------------------------------------------------------------------------------------

Тема курсовой работы:

Система биллинга для корпоративной сети телефонной связи.

------------------------------------------------------------------------------------------------------------------------------------------------

Основные положения и терминология.

--
Биллингом (или тарификацией) называют процесс рассчёта стоимости телефонных вызовов и привязки их к абонентам с целью выставления счетов на оплату.

Сеть корпоративной телефонии представляет собой логически объединенную с помощью каналов связи, протоколов и общего нумерационного плана группу 
телефонныз станций (АТС), телефонных серверов, шлюзов и абонентских устройств.

Нумерационный план - общие для всех устройств тел.сети правила набора номеров.

Оператор телефонии - "провайдер", предоставляющий каналы входящей и исходящей телефонной связи в телефонную сеть общего пользования (ТфОП).
Операторы предоставляют своим клиентам федеральные номера (+7....) и обеспечивают звонки за пределами корпоративной телефонной сети.

Собственно процесс биллинга и направлен на отслеживание и рассчёт взаимодействия с операторами.
Каждый узел тел.сети, взаимодействующий с провайдером напрямую через каналы связи (транки), подлежит тарификации. 
Для этого узел гененрирует информацию о вызовах, называемую CDR (Call Detail Record).
В CDR записывается вся необходимая и достаточная информация о вызовах прошедших через данную АТС\сервер, а именно номера входящего и исходящего абонентов,
дата и время вызова, длительность, входящие и исходящие каналы, какие-то дополнительные детали вызова - например протокол связи, причины отбоя и т.д.
С цифровых АТС CDR как правило получаем виде текстового файла, а телефонные серверы обычно могут сразу сами записывать CDR сразу в СУБД.

------------------------------------------------------------------------------------------------------------------------------------------------

Архитектура системы

--

В этой работе мы будем брать CDR от телефонных серверов Asterisk.
Asterisk - это самое популярное решение для IP-телефонии, он умеет записывать CDR сразу в базу PostgreSQL (как впрочем и в другие СУБД).
Но в нашей сети исторически сложилось так что все CDR "сливаются" в базы MySQL, поэтому придётся взаимодействовать сразу с двумя СУБД.
Реализовать весь процесс биллинга непосредственно в базе данных в принципе, наверное, возможно, но это было бы неудобно 
т.к. любые изменения алгоритма будут требовать коррекции БД.
Также неплохо бы сразу заложить в систему возможность распараллеливать обработку по разным физическим серверам, 
т.е. саму БД и модули биллинга лучше разделить.
Поэтому мы будем реализовывать модульную архитектуру: БД в СУБД PostgreSQL и MySQL, а модули тарификации напишем на Python.

Процесс тарификации мы разделим на несколько логических этапов, каждый из которых будет представлять из себя отдельную и независимую программу на Python, взаимодействующую с БД биллинга и больше ни с чем.
Обрабатывать каждый модуль может за раз только одну строку БД биллинга (но в целях оптимизации в будущем можно обрабатывать и по несколько строк).
Т.о. мы можем разные экземпляры одиного модуля запускать на разных серверах - этим мы достигнем распределение нагрузки и отказоустойчивость системы.
Такое узкое место в смысле отказоустойчивости как сама БД биллинга можно обойти зазеркалив сам сервер СУБД PostgreSQL. 
--
Итак, приступим!

------------------------------------------------------------------------------------------------------------------------------------------------

Подготовка инфраструктуры

Серверы Asterisk в нашей сети работают на Centos, данные CDR записываются в базы MySQL.
Для нашей работы мы будем использовать вирт. машину с сервером Ubuntu 20.04, на него установим PostgreSQL 12 и Python 3.
Также будем использовать компьютер Win10 с SQL Manager и\или Dbeaver в качестве графической оболочки для доступа к БД, 
и VSCode для отладки модулей на Python.
Всё находится в одной локальной сети.
Описывать настройку ОС Ubuntu, серверов SQL и других программ тут не будем - это всё хорошо описано в интернете. 

------------------------------------------------------------------------------------------------------------------------------------------------

Проектирование базы данных.

Основа нашей БД биллинга - данные из БД CDR.
Посмотрим какие данные мы будем получать на входе - вот структура таблицы CDR в БД MySQL:
(не все данные нам понадобятся)

CREATE TABLE `cdr` (
  `ID` INTEGER(11) NOT NULL AUTO_INCREMENT,
  `marked` TINYINT(4) NOT NULL DEFAULT '0',
  `calldate` DATETIME NOT NULL DEFAULT '0000-00-00 00:00:00',
  `src` VARCHAR(80) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `dst` VARCHAR(80) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `dcontext` VARCHAR(80) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `channel` VARCHAR(80) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `dstchannel` VARCHAR(80) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `duration` INTEGER(11) NOT NULL DEFAULT '0',
  `billsec` INTEGER(11) NOT NULL DEFAULT '0',
  `lastapp` VARCHAR(80) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `lastdata` VARCHAR(80) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  `disposition` VARCHAR(45) COLLATE utf8_general_ci NOT NULL DEFAULT '',
  PRIMARY KEY (`ID`),
  UNIQUE KEY `ID` (`ID`),
  KEY `calldate` (`calldate`),
  KEY `dst` (`dst`),

)ENGINE=MyISAM
AUTO_INCREMENT=196920 CHARACTER SET 'utf8' COLLATE 'utf8_unicode_ci';

-- описание полей:

marked     - метка считано\не считано
calldate   - дата и время поступления вызова;
src        - входящий номер (абонент А);
dst        - исходящий канал (абонент Б);
channel    - входящий канал;
dstchannel - исходящий канал;
dcontext   - "контекст" вызова в asterisk;
duration   - длительность вызова в секундах;
billsec    - длительность вызова после ответа аб.Б в секундах;
lastapp    - имя ф-ции обработавшей вызов;
lastdata   - параметры ф-ции обработавшей вызов;
disposition - статус вызова; 

Зайдём в консоль PostgreSQL сервера и создадим БД, пользователя-администратора нашей базы, дадим ему права:

# sudo su - postgres
$ psql
postgres=# CREATE DATABASE billdb WITH ENCODING='UTF-8';
CREATE DATABASE
postgres=# CREATE USER billadmin WITH PASSWORD 'billadminpwd';
CREATE ROLE
postgres=# \c billdb
You are now connected to database "billdb" as user "postgres".
billdb=# GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO "billadmin";
GRANT

# psql -Ubilladmin billdb -hlocalhost
Password for user billadmin:
psql (12.4 (Ubuntu 12.4-0ubuntu0.20.04.1))

billdb=>

------------------------------------------------------------------------------

Начнём создавать таблицы:

-- Таблица вызовов - главная таблица базы,
   сюда попадают "сырые" данные CDR которые генерируют АТС, 
   после чего они последовательно обрабатываются, а результаты обработки заносятся с соответствующие поля

CREATE TABLE public.paidcalls (
  id BIGSERIAL,
  calldate TIMESTAMP WITH TIME ZONE DEFAULT '1111-01-01 00:00:00+02:30:17'::timestamp with time zone NOT NULL,
  channel VARCHAR DEFAULT ''::character varying NOT NULL,
  dstchannel VARCHAR DEFAULT ''::character varying NOT NULL,
  src VARCHAR(20) DEFAULT ''::character varying NOT NULL,
  dst VARCHAR(20) DEFAULT ''::character varying NOT NULL,
  dcontext VARCHAR(20) NOT NULL,
  client_id INTEGER,
  client VARCHAR(80) DEFAULT ''::character varying,
  prefix_id INTEGER,
  code_id INTEGER,
  code VARCHAR(20),
  number VARCHAR(20) DEFAULT ''::character varying,
  duration BIGINT DEFAULT 0 NOT NULL,
  billsec BIGINT DEFAULT 0 NOT NULL,
  billmin BIGINT DEFAULT 0 NOT NULL,
  price MONEY DEFAULT 0 NOT NULL,
  total MONEY DEFAULT 0 NOT NULL,
  status public.enum_paidcalls_status DEFAULT 'new record'::enum_paidcalls_status NOT NULL,
  CONSTRAINT paidcalls_pkey PRIMARY KEY(id),
  CONSTRAINT paidcalls_fk_client FOREIGN KEY (client_id)
    REFERENCES public.client(id)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
    NOT DEFERRABLE,
  CONSTRAINT paidcalls_fk_prefix FOREIGN KEY (prefix_id)
    REFERENCES public.prefix(id)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
    NOT DEFERRABLE,
  CONSTRAINT paidcalls_fk_tarif FOREIGN KEY (code_id)
    REFERENCES public.tarif(id)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
    NOT DEFERRABLE
) ;

COMMENT ON COLUMN public.paidcalls.calldate
IS 'дата и время поступления вызова';

COMMENT ON COLUMN public.paidcalls.channel
IS 'входящий канал';

COMMENT ON COLUMN public.paidcalls.dstchannel
IS 'исходящий канал';

COMMENT ON COLUMN public.paidcalls.src
IS 'входящий номер (абонент А)';

COMMENT ON COLUMN public.paidcalls.dst
IS 'исходящий канал (абонент Б)';

COMMENT ON COLUMN public.paidcalls.dcontext
IS '"контекст" вызова в asterisk';

COMMENT ON COLUMN public.paidcalls.client_id
IS 'ключ к таблице клиентов';

COMMENT ON COLUMN public.paidcalls.client
IS 'имя клиента (продублируем для удобства)';

COMMENT ON COLUMN public.paidcalls.prefix_id
IS 'ключ к таблице префиксов';

COMMENT ON COLUMN public.paidcalls.code_id
IS 'ключ к таблице тел.кодов';

COMMENT ON COLUMN public.paidcalls.code
IS 'найденный телефонный код';

COMMENT ON COLUMN public.paidcalls.number
IS 'выделенный номер абонента Б';

COMMENT ON COLUMN public.paidcalls.duration
IS 'длительность вызова в секундах';

COMMENT ON COLUMN public.paidcalls.billsec
IS 'длительность вызова после ответа аб.Б в секундах';

COMMENT ON COLUMN public.paidcalls.billmin
IS 'тарифицируемая длительность вызова в минутах';

COMMENT ON COLUMN public.paidcalls.price
IS 'стоимость минуты';

COMMENT ON COLUMN public.paidcalls.total
IS 'общая стоимость вызова';

CREATE INDEX paidcalls_idx_client ON public.paidcalls
  USING btree (client_id);

CREATE TRIGGER calc_minutes_trigger
  AFTER INSERT 
  ON public.paidcalls
  
FOR EACH ROW 
  EXECUTE PROCEDURE public.calc_minutes();

ALTER TABLE public.paidcalls
  OWNER TO billadmin;

----------------------------------------------------------------------------
-- Создадим перчисляемый тип, который нужен для отслеживания статуса обработки данных вызова

CREATE TYPE public.enum_paidcalls_status AS ENUM (
    'new record', 'client undefined', 'client defined', 'incoming', 'prefix defined', 
    'local call', 'tarif defined', 'tarif undefined'
);

ALTER TYPE public.enum_paidcalls_status
  OWNER TO billadmin;

-----------------------------------------------------------------------------
-- таблица абонентов: по ней определяется тариф (у каждого абонента может же быть свой тариф)

CREATE TABLE public.client (
  id SERIAL,
  name VARCHAR(1) DEFAULT 'noname'::character varying NOT NULL,
  tarif_id SMALLINT DEFAULT 0 NOT NULL,
  CONSTRAINT client_pkey PRIMARY KEY(id)
) ;

COMMENT ON COLUMN public.client.name
IS 'название клиента';

COMMENT ON COLUMN public.client.tarif_id
IS 'номер тарифа';

ALTER TABLE public.client
  OWNER TO billadmin;

----------------------------------------------------------------------------
-- таблица номеров абонентов: у каждого абонента может быть несколько номеров
-- через номер в этой таблице ищем звонящего абонента 

CREATE TABLE public.callerid (
  id SERIAL,
  client_id INTEGER DEFAULT 0 NOT NULL,
  callerid VARCHAR(20) DEFAULT ''::character varying NOT NULL,
  CONSTRAINT callerid_callerid_key UNIQUE(callerid),
  CONSTRAINT callerid_pkey PRIMARY KEY(id),
  CONSTRAINT callerid_fk_client FOREIGN KEY (client_id)
    REFERENCES public.client(id)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION
    NOT DEFERRABLE
) ;

COMMENT ON COLUMN public.callerid.client_id
IS 'ключ к таблице клиентов';

COMMENT ON COLUMN public.callerid.callerid
IS 'CallerID клиента';

----------------------------------------------------------------------------
-- таблица префиксов: по ней определяем тип вызова

CREATE TABLE public.prefix (
  id SERIAL,
  prefix VARCHAR(20) DEFAULT ''::character varying NOT NULL,
  description VARCHAR,
  CONSTRAINT prefix_pkey PRIMARY KEY(id),
  CONSTRAINT prefix_prefix_key UNIQUE(prefix)
) ;

COMMENT ON COLUMN public.prefix.prefix
IS 'префикс';

COMMENT ON COLUMN public.prefix.description
IS 'описание префикса';

ALTER TABLE public.prefix
  OWNER TO billadmin;

-------------------------------------------------------------------------------------
-- таблица тарифов: в неё заносятся все тарифы по каждому префиксу и телефонному коду
   по сути весь процесс тарификации сводится к поиску нужной строки в этой таблице

CREATE TABLE public.tarif (
  id SERIAL,
  tarifnum INTEGER DEFAULT 1 NOT NULL,
  prefixes SMALLINT [],
  code VARCHAR(20) DEFAULT ''::character varying NOT NULL,
  description VARCHAR(80) DEFAULT ''::character varying NOT NULL,
  price MONEY DEFAULT 0 NOT NULL,
  CONSTRAINT tarif_pkey PRIMARY KEY(id)
) ;

COMMENT ON COLUMN public.tarif.tarifnum
IS 'номер тарифа';

COMMENT ON COLUMN public.tarif.code
IS 'телефонный код';

COMMENT ON COLUMN public.tarif.description
IS 'населённый пункт';

CREATE INDEX code_idx ON public.tarif
  USING btree (code COLLATE pg_catalog."default");

CREATE INDEX combo_idx ON public.tarif
  USING btree (tarifnum, prefixes);

ALTER TABLE public.tarif
  OWNER TO billadmin;

ALTER TABLE public.tarif
  ALTER COLUMN prefixes SET STORAGE EXTENDED;

--------------------------------------------------------------------------------------------------------------

-- Модуль переноса CDR из базы MySQL в PostgreSQL.

Модуль отличается от всех остальных тем что данные обрабатываются не построчно а все сразу:
данные состоявшихся звонков АТС записывают в БД MySQL в реальном времени, и нам нужно с определённой периодичностью проверять их поступление,
переносить в БД PostgreSQL биллинга и помечать как считанные. 
В смысле нагрузки выгоднее считывать сразу все новые записи из базы каждого астериска, а нагрузку распределить запуском нескольких модулей,
чтобы каждый работал со своим телефонным сервером.   
Т.о. сначала делается выборка всех свежих (т.е. ранее необработанных) записей, тех у которых метка marked = 0, а также длительность разговора ненулевая.
Затем этот список (кортежей) вставляется в базу биллинга в PostgreSQL.
Нужно ли переносить и обрабатывать вызовы с нулевой длительностью и соответственно нулевой стоимостью - это отдельный вопрос, 
т.к. для получения определённой статистики это необходимо, но в данной работе мы делаем чистый биллинг, поэтому не будем их обрабатывать и будем сразу 
метить как обработанные.

Код модуля CDRtransfer.py показывает всё в деталях (прикреплён к работе).

Приведём образец результатов работы модуля:  

billdb=# select * from paidcalls limit 10;

 id |        calldate        |      channel      |             dstchannel             |     src     | dst | dcontext | client_id | client | prefix_id | code_id | number | duration | billsec | billmin | price | total | provider_id |   status
----+------------------------+-------------------+------------------------------------+-------------+-----+----------+-----------+--------+-----------+---------+--------+----------+---------+---------+-------+-------+-------------+------------
 88 | 2020-09-01 07:38:18+03 | SIP/480-00006150  | IAX2/RELERO-27095                  | 480         | 900 | Oct60    |           |        |           |         |        |       17 |      10 |       1 |     0 |     0 |             | new record
 89 | 2020-09-01 08:22:58+03 | SIP/480-00006151  | IAX2/RELERO-26531                  | 480         | 900 | Oct60    |           |        |           |         |        |       18 |       9 |       1 |     0 |     0 |             | new record
 90 | 2020-09-01 08:29:39+03 | IAX2/RELERO-13521 | SIP/480-00006152                   | 932         | 480 | Oct60    |           |        |           |         |        |        9 |       5 |       1 |     0 |     0 |             | new record
 91 | 2020-09-01 08:33:59+03 | SIP/480-00006153  | IAX2/RELERO-27393                  | 480         | 932 | Oct60    |           |        |           |         |        |      106 |     104 |       1 |     0 |     0 |             | new record
 92 | 2020-09-01 08:56:27+03 | IAX2/RELERO-16036 | SIP/480-00006154                   | 911         | 480 | Oct60    |           |        |           |         |        |       23 |      21 |       1 |     0 |     0 |             | new record
 93 | 2020-09-01 08:59:41+03 | IAX2/RELERO-899   | SIP/480-00006155                   | 928         | 480 | Oct60    |           |        |           |         |        |       21 |      19 |       1 |     0 |     0 |             | new record
 94 | 2020-09-01 09:05:36+03 | SIP/457-00006156  | IAX2/RELERO-25332                  | 457         | 363 | Oct60    |           |        |           |         |        |      118 |     115 |       1 |     0 |     0 |             | new record
 95 | 2020-09-01 09:25:36+03 | IAX2/RELERO-15264 | SIP/469-00006157                   | 84242515555 | 469 | IVR-new  |           |        |           |         |        |       20 |      20 |       1 |     0 |     0 |             | new record
 96 | 2020-09-01 09:25:57+03 | IAX2/RELERO-15264 | Local/89163933502@Oct60-0000075d;1 | 84242515555 | 469 | IVR-new  |           |        |           |         |        |        6 |       6 |       1 |     0 |     0 |             | new record
 97 | 2020-09-01 09:26:03+03 | IAX2/RELERO-15264 | IAX2/RELERO-18022                  | 84242515555 | 469 | IVR-new  |           |        |           |         |        |     1424 |    1424 |       1 |     0 |     0 |             | new record
(10 rows)

--------------------------------------------------------------------------------------------------------------

-- Модуль определения клиента.

Данный модуль должен по номеру звонящего абонента (абонент А) вычислять кто звонил, и соответственно, определять тип звонка, 
id абонента и его тарифный план.

Сначала проверим правильно ли работает наша структура таблиц:
тут будет полезно сделать FOREIGN KEY c каскадным удалением и обновлением - проверим что всё это работает как нам надо:

CREATE TABLE public.client (
  id SERIAL,
  name VARCHAR(80) DEFAULT 'noname'::character varying NOT NULL,
  tarifnum INTEGER DEFAULT 0 NOT NULL,
  CONSTRAINT client_pkey PRIMARY KEY(id)
) ;

CREATE TABLE public.callerid (
  id SERIAL,
  client_id INTEGER DEFAULT 0 NOT NULL,
  callerid VARCHAR(20) DEFAULT ''::character varying NOT NULL,
  CONSTRAINT callerid_callerid_key UNIQUE(callerid),
  CONSTRAINT callerid_pkey PRIMARY KEY(id),
  CONSTRAINT callerid_fk_client FOREIGN KEY (client_id)
    REFERENCES public.client(id)
    ON DELETE CASCADE
    ON UPDATE CASCADE
    NOT DEFERRABLE
) ;

billdb=# select * from client;
 id | name | tarifnum
----+------+----------
  1 | вася |        1
  2 | петя |        2
  3 | ира  |        5
(3 rows)

billdb=# select * from callerid;
 id | client_id | callerid
----+-----------+----------
  1 |         1 | 12345
  2 |         2 | 49649646
  3 |         3 | 333
  5 |         1 | 25454
  6 |         3 | 344324
  4 |         2 | 2412234


billdb=# SELECT client.name, callerid.callerid FROM client INNER JOIN callerid ON client.id = callerid.client_id ORDER BY client.name;
 name | callerid
------+----------
 вася | 12345
 вася | 25454
 ира  | 333
 ира  | 344324
 петя | 49649646
 петя | 2412234

billdb=# DELETE FROM client WHERE client.id = 2;

billdb=# SELECT client.name, callerid.callerid FROM client INNER JOIN callerid ON client.id = callerid.client_id ORDER BY client.name;
 name | callerid
------+----------
 вася | 12345
 вася | 25454
 ира  | 333
 ира  | 344324

billdb=# select * from callerid;
 id | client_id | callerid
----+-----------+----------
  1 |         1 | 12345
  3 |         3 | 333
  5 |         1 | 25454
  6 |         3 | 344324

billdb=# select * from client;
 id | name | tarifnum
----+------+----------
  1 | вася |        1
  3 | ира  |        5

т.е. при удалении клиента автоматом удалились и его номера - то что нужно!

Теперь наоборот - при удалении номера клиента сам клиент удаляться не должен:

billdb=# DELETE FROM callerid WHERE callerid.callerid = '12345';
DELETE 1
billdb=# select * from client;
 id | name | tarifnum
----+------+----------
  1 | вася |        1
  3 | ира  |        5

billdb=# select * from callerid;
 id | client_id | callerid
----+-----------+----------
  3 |         3 | 333
  5 |         1 | 25454
  6 |         3 | 344324

Всё как нам и надо!

Проверим UPDATE:

billdb=# select * from client;
 id | name | tarifnum
----+------+----------
  1 | вася |        1
  3 | ира  |        5
  5 | петя |        3

billdb=# select * from callerid;
 id | client_id | callerid
----+-----------+----------
  5 |         1 | 911
  6 |         3 | 468
  8 |         1 | 932
  3 |         3 | 481
  9 |         5 | 363
 10 |         5 | 900

billdb=# UPDATE client SET id = 11 WHERE id = 1;
UPDATE 1

billdb=# select * from client;
 id | name | tarifnum
----+------+----------
  3 | ира  |        5
  5 | петя |        3
 11 | вася |        1

billdb=# select * from callerid;
 id | client_id | callerid
----+-----------+----------
  6 |         3 | 468
  3 |         3 | 481
  9 |         5 | 363
 10 |         5 | 900
  5 |        11 | 911
  8 |        11 | 932

видим что при обновлении ид клиента его ид в номерах обновляются автоматом - тоже всё как надо!

Далее перейдём непосредственно к модулю поиска клиента.
Здесь и далее везде, дабы исключить повреждение данных и конкуренцию при параллельной их обработке экземплярами модулей,
мы будем применять транзакции. В python это реализовано с помощью конструкции with...

Логика работы модуля такая: 
- считываем из таблицы paidcalls одну новую запись если она есть 
- смотрим есть ли исходящий номер dst в таблице номеров callerid;
  - если есть - это вызов входящий, т.е. бесплатный, и дальнейшая тарификация не нужна:
	обновляем нашу строку paidcalls данными клиента client_id и имя, 
	метим строку 'incoming' и завершаем транзакцию.
  - если нет - ищем входящий номер src в таблице номеров callerid.
    если есть - это вызов исходящий, клиент определён;
	обновляем нашу строку paidcalls данными клиента client_id и имя; 
	метим строку 'client defined' и завершаем транзакцию.
- если вообще не нашли: метим строку 'client undefined', завершаем транзакцию.

Т.к. все изменения делаются в пределах одной транзакции данные защищены от параллельного редактирования автоматически, 
и нам не нужно специально синхронизировать работу модулей в любом колличестве.

Результаты работы модуля ClientDefinition.py:

billdb=# select id, calldate, src, dst, client_id, client, status from paidcalls order by id;
 id  |        calldate        | src |     dst     | client_id | client |      status
-----+------------------------+-----+-------------+-----------+--------+------------------
 128 | 2020-09-01 12:33:15+03 | 486 | 100         |           |        | client undefined
 129 | 2020-09-01 12:38:47+03 | 100 | 486         |           |        | client undefined
 130 | 2020-09-01 12:42:46+03 | 220 | 467         |         2 | аня    | client defined
 131 | 2020-09-01 12:45:11+03 | 467 | 220         |         2 | аня    | incoming
 132 | 2020-09-01 12:49:09+03 | 480 | 100         |         3 | ира    | client defined
 133 | 2020-09-01 12:49:26+03 | 486 | 100         |           |        | client undefined
 134 | 2020-09-01 12:53:24+03 | 486 | 100         |           |        | client undefined
 135 | 2020-09-01 12:54:45+03 | 945 | 480         |         3 | ира    | incoming
 136 | 2020-09-01 12:56:56+03 | 494 | 89645224966 |           |        | client undefined
 137 | 2020-09-01 12:58:02+03 | 480 | 904         |         3 | ира    | client defined

--------------------------------------------------------------------------------------------------------------

-- Модуль определения префиксов.

Приступим к определению того куда клиент звонил - от этого зависит стоимость вызова.
Все дальнейшие операции производятся только для тех вызовов, которые определены как исходящие, и клиент определён, 
т.е. для тех у которых поле status установлено как client defined.

Для этого мы должны разложить исходящий номер (dst) на несколько компонентов в соответствии с нашим нумерационным планом.

В исходящий набор могут входить следующие компоненты:
- префикс: используется для определения вида связи (междугородняя, международная, местная, региональная и т.д.)
- код страны: используется при международной связи и при наборе по стандарту E.164
- код региона (или код оператора): используется для маршрутизации внутри отдельной страны
- локальный номер абонента: номер абонента внутри региона 

В федеральной телефонной сети России принято использовать нумерационный план со следующими правилами набора: 
- для звонков внутри России: префикс-код города-номер абонента, например: 8-495-1234567
  здесь 8 - префикс, 495 - код региона, 1234567 - локальный номер абонента
- для международных звонков из России: префикс-код страны-код города-номер абонента, например: 810-1-202-8270880
  здесь 810 - префикс, 1 - код страны, 202 - код региона, 8270880 - локальный номер абонента
- мобильные операторы позволяют также набирать номер по международному стандарту E.164: +7-903-1234567
  здесь + - признак того что далее пойдёт полный международный номер в стандарте E.164 (фактически это префикс), 
  7 - код страны, 903 - код оператора, 1234567 - локальный номер абонента
- локальные звонки внутри региона: просто номер абонента, например 123456 (в Москве и некоторых других регионах запрещены)

В корпоративной телефонии также допустимы любые другие наборы, например короткие номера 3-4 цифры, префиксы выхода "в город" и т.д. 

Т.о. мы имеем несколько видов наборов разной структуры, и часто переменной длины 
В России фиксированная длина федерального номера 10 знаков, но во многих странах длина номера нефиксированная.

Для разбора будем использовать следующий принцип: 
если из набора можно выделить префикс, то вызов считается тарифицируемым, если нет - локальным, т.е. нетарифицируемым.
Если вызов входящий - он также нетарифицируемый (если понадобится можно протарифицировать и входящие, но нам не нужно).

Начнём с модуля префиксов.
Таблица префиксов обычно небольшая, и типичный её вид такой:

billdb=# select * from prefix;
 id | prefix | description
----+--------+-------------
  1 | 8      | МГ
  2 | 810    | МН
  3 | +      | E.164

Наша задача найти максимально длинное соответствие между набором dst из таблицы paidcalls начиная слева, и полем prefix из одноимённой таблицы.
Т.е, как пример, имея набор 81012028270880 алгоритм должен выделять префикс не 8 а 810 т.к. хотя оба они начинаются с "8" но "810" длиннее. 

Результаты работы модуля PrefixDefinition.py:

billdb=# SELECT id, calldate, src, dst, client_id, client, prefix_id, status FROM paidcalls order by id;
 id  |        calldate        |     src     |      dst      | client_id | client | prefix_id |      status
-----+------------------------+-------------+---------------+-----------+--------+-----------+------------------
 148 | 2020-09-01 13:48:40+03 | 498         | 89855133184   |         3 | ира    |         1 | prefix defined
 149 | 2020-09-01 13:51:00+03 | 442         | 467           |         3 | ира    |           | local call
 150 | 2020-09-01 14:00:18+03 | 480         | 89855133184   |         1 | таня   |           | incoming
 152 | 2020-09-01 14:04:49+03 | 89855133184 | 1             |           |        |           | client undefined
 153 | 2020-09-01 14:04:52+03 | 442         | 444           |         3 | ира    |           | local call
 156 | 2020-09-01 14:10:26+03 | 100         | 8109855133184 |         1 | таня   |         2 | prefix defined
 157 | 2020-09-01 14:12:20+03 | 480         | 932           |        11 | вася   |           | incoming
 158 | 2020-09-01 14:17:55+03 | 442         | 84956480111   |         3 | ира    |         1 | prefix defined
 159 | 2020-09-01 14:23:24+03 | 100         | +79855133184  |         1 | таня   |         3 | prefix defined

billdb=# SELECT paidcalls.id, dst, prefix_id, prefix.prefix FROM paidcalls INNER JOIN prefix ON paidcalls.prefix_id = prefix.id WHERE status = 'prefix defined';
 id  |      dst      | prefix_id | prefix
-----+---------------+-----------+--------
 148 | 89855133184   |         1 | 8
 156 | 8109855133184 |         2 | 810
 158 | 84956480111   |         1 | 8
 159 | +79855133184  |         3 | +
 
Т.е. префиксы определяются верно, и мы можем перейти к главной задаче - определению телефонных кодов и, соответственно, тарифов.

----------------------------------------------------------------------------------------------------------------------------------------------

-- Модуль определения телефонных кодов и тарифов.

Принцип определения тел.кодов аналогичен определению префиксов, но есть одно существенное отличие:
таблица префиксов совсем небольшая, а таблица кодов может содержать десятки и сотни тысяч записей т.к. на каждый тарифный план может быть 
свой набор кодов, а тел.коды с тарифами во многих странах расписаны очень подробно, и провайдеры присылают порой огромные таблицы тарифов.
При этом нам желательно сохранить структуру таблицы tarif так, чтобы она была удобна и совместима для импорта тарифов из экселевских таблиц 
(их обычно в таком виде присылают провайдеры). Импорт таблиц из экселя в БД удобно делать с помощью SQL Manager или DBeaver.
Поэтому решение данного вопроса будет компромиссное: с одной стороны мы не будем усложнять структуру БД дополнительными таблицами и их связями, 
но при этом постараемся максимально уменьшить объём предварительных выборок при обработке данных.

Импортируем данные из экселя с помощью SQL Manager для тарифов 1 и 2, и посмотрим что получилось:

billdb=# select count(*) from tarif;
 count
-------
 12324
(1 row)

т.е. у нас 12324 записи

billdb=# select * from tarif where tarifnum = 1 limit 10;
 id | tarifnum | prefixes | code  |           description           | price
----+----------+----------+-------+---------------------------------+--------
 23 |        1 | {1}      | 855   | Россия Татарстан                | 1,98 ?
 24 |        1 | {1}      | 485   | Ярославская-область             | 1,98 ?
 25 |        1 | {1}      | 4852  | ЯРОСЛАВЛЬ                       | 1,98 ?
 26 |        1 | {1}      | 349   | Ямало-Ненецкий автономный округ | 1,98 ?
 27 |        1 | {1}      | 4112  | ЯКУТСК                          | 1,98 ?
 28 |        1 | {1}      | 4242  | ЮЖНО-САХАЛИНСК                  | 1,98 ?
 29 |        1 | {1}      | 84722 | ЭЛИСТА                          | 1,98 ?
 30 |        1 | {1}      | 391   | Эвенкийский автономный округ    | 1,98 ?
 31 |        1 | {1}      | 427   | Чукотский автономный округ      | 1,98 ?
 32 |        1 | {1}      | 3022  | ЧИТА                            | 1,98 ?
(10 rows)

billdb=# select * from tarif where tarifnum = 2 order by id desc limit 10;
  id  | tarifnum | prefixes | code  |     description     | price
------+----------+----------+-------+---------------------+--------
 6482 |        2 | {2,3}    | 99890 | Узбекистан моб.     | 5,99 ?
 6481 |        2 | {2,3}    | 7     | Россия рег. стац.   | 2,00 ?
 6480 |        2 | {2,3}    | 7499  | Россия Москва стац. | 0,60 ?
 6479 |        2 | {2,3}    | 7495  | Россия Москва стац. | 0,60 ?
 6478 |        2 | {2,3}    | 79    | Россия моб.         | 2,10 ?
 6477 |        2 | {2,3}    | 8190  | Япония моб.         | 9,05 ?
 6476 |        2 | {2,3}    | 8180  | Япония моб.         | 9,05 ?
 6475 |        2 | {2,3}    | 8170  | Япония моб.         | 9,05 ?
 6474 |        2 | {2,3}    | 8150  | Япония IP Phone     | 4,16 ?
 6473 |        2 | {2,3}    | 81    | Япония              | 4,16 ?
(10 rows)


Хотелось бы обратить внимание на один интересный момент, связанный с работой с типом данных "массив":
для того чтобы сразу отсечь все неподходящие для данного вызова тарифные планы и префиксы мы делаем в коде модуля такой запрос:

SELECT id, code, price FROM tarif WHERE tarifnum = (SELECT tarifnum FROM client WHERE id = client_id) AND  prefix_id = ANY (prefixes);

Тут мы видим приём работы с данными типа массив: 
условие WHERE prefix_id = ANY (prefixes) проверяет в массиве, лежащем в поле prefixes, наличие хоты бы одного значения переменной prefix_id.
Т.о. одним запросом мы уменьшаем объём требуемых выборок во много раз, сильно не усложняя при этом алгоритм. 

После того как мы нашли строку с определённым кодом в таблице тарифов, мы получаем стоимость минуты разговора.
Т.к. у нас поминутная тарификация (возможна и посекундная, и комбинированная - это решаемо, но не будем распыляться), 
то для определения стоимости вызова мы должны тариф умножить на кол-во тарифицируемых минут.
Это несколько усложняет задачу, т.к. нам нужно перевести секунды в минуты с округлением в большую сторону.
Эту операцию мы не будем производить в каком либо модуле - мы это сделаем с помощью функции в самой БД, 
а запускать её будем с помощью триггера привязанного к вставке строки в таблицу paidcalls:

CREATE OR REPLACE FUNCTION public.calc_minutes (
)
RETURNS trigger AS
$body$
BEGIN
    UPDATE paidcalls SET billmin = CEILING(billsec::float/60);
    RETURN NULL;
END
$body$
LANGUAGE 'plpgsql'
VOLATILE
CALLED ON NULL INPUT
SECURITY INVOKER
PARALLEL UNSAFE
COST 100;

CREATE TRIGGER calc_minutes_trigger
  AFTER INSERT 
  ON public.paidcalls
  
FOR EACH ROW 
  EXECUTE PROCEDURE public.calc_minutes();

проверяем:
  
billdb=# select billsec, billmin  from paidcalls;
 billsec | billmin
---------+---------
      77 |       2
       8 |       1
      49 |       1
      22 |       1
      39 |       1
     115 |       2
     581 |      10
      32 |       1
       5 |       1
       9 |       1
      20 |       1
      43 |       1
      30 |       1
     638 |      11
       7 |       1
      28 |       1
     143 |       3
      31 |       1
      11 |       1
      42 |       1

Видим что всё пересчитывается верно, и мы можем посчитать стоимость вызова перемножая содержимые полей стоимости и минут прямо в UPDATE.

Результат работы модуля CodeDefinition.py :

billdb=# SELECT calldate, src, dst, client, paidcalls.code, number, tarif.description, billsec, billmin, paidcalls.price, total
billdb-# FROM paidcalls
billdb-# INNER JOIN tarif ON paidcalls.code_id = tarif.id
billdb-# WHERE status = 'tarif defined' ORDER BY calldate LIMIT 10;
        calldate        | src |      dst      | client | code |   number   |   description   | billsec | billmin | price  |  total
------------------------+-----+---------------+--------+------+------------+-----------------+---------+---------+--------+---------
 2020-09-01 13:48:40+03 | 498 | 89855133184   | ира    | 9855 | 133184     | Моб             |    1974 |      33 | 1,80 ? | 59,40 ?
 2020-09-01 14:00:18+03 | 480 | 89855133184   | ира    | 9855 | 133184     | Моб             |       9 |       1 | 1,80 ? |  1,80 ?
 2020-09-01 14:10:26+03 | 100 | 8103755133184 | таня   | 375  |            | Белоруссия Лука |     130 |       3 | 5,90 ? | 17,70 ?
 2020-09-01 14:17:55+03 | 442 | 84956480111   | ира    | 495  | 6480111    | Москва          |       7 |       1 | 0,60 ? |  0,60 ?
 2020-09-01 14:23:24+03 | 100 | +13425133184  | таня   | 1    | 3425133184 | США             |       1 |       1 | 0,91 ? |  0,91 ?
 2020-09-01 14:34:34+03 | 442 | 84956480111   | ира    | 495  | 6480111    | Москва          |     170 |       3 | 0,60 ? |  1,80 ?
 2020-09-01 15:58:08+03 | 442 | 84955874346   | ира    | 495  | 5874346    | Москва          |     204 |       4 | 0,60 ? |  2,40 ?
 2020-09-01 16:17:50+03 | 442 | 84957483898   | ира    | 495  | 7483898    | Москва          |     846 |      15 | 0,60 ? |  9,00 ?
 2020-09-01 17:10:50+03 | 498 | 84957847313   | ира    | 495  | 7847313    | Москва          |     250 |       5 | 0,60 ? |  3,00 ?

Исходящие вызовы тарифицируются - чего мы и добивались!

Для подсчёта суммы для клиента добавим в БД вид (представление):

CREATE VIEW public.client_sum (
    total)
AS
SELECT sum(paidcalls.total) AS total
FROM paidcalls
WHERE paidcalls.client_id = 1;

И напоследок сделаем резервное копирование базы - его можно запускать как вручную, так и по расписанию, напримере через crontab.

$ pg_dump billdb > billdb.dump

----------------------------------------------------------------------------------------------------------------------------------------------

-- Запуск системы

Итак, мы достигли поставленой цели: при наличии нужных данных мы можем обсчитать любой вызов.
Осталось наполнить БД данными: таблицу тарифов мы будем заполнять с помощью импорта данных из формата эксель с помощью SQL Manager и\или Dbeaver,
а остальные таблицы можно заполнить или вручную, или тоже импортом - зависит от кол-ва данных.

Осталось решить вопрос как всё это запускать.
Как я уже говорил в разделе Архитектура, модульность системы позволяет гибко регулировать кол-во и частоту запускаемых модулей в зависимости от нагрузки.  

В случае небольшой нагрузки можно запускать сервер PostgreSQL и модули биллинга на одной вирт.машине с линуксом, а её ресурсы (ядра, память, диски и т.д.) 
регулировать в гипервизоре.
Запускать систему можно через единый bash скрипт, например billing.sh, в котором просто последовательно запускать модули, 
а сам скрипт запускать через crontab с определённой периодичностью, например так: 

#cat billing.sh
#!/bin/bash
./python3 /etc/billing/CDRtransfer-ATC1.py
./python3 /etc/billing/CDRtransfer-ATC2.py
./python3 /etc/billing/CDRtransfer-ATC3.py
./python3 /etc/billing/ClientDefinition.py
./python3 /etc/billing/PrefixDefinition.py
./python3 /etc/billing/CodeDefinition.py
 
# crontab -l
* * * * * /etc/billing/billing.sh
 
Т.е. мы запускаем все наши модули последовательно кадую минуту, причём модуль CDRtransfer мы запускаем для каждой АТС отдельно.

Если нагрузка высокая, или требования к актуальности биллинга разные, или каналы связи не отличаются стабильностью (такое бывает например если сеть
связи распределена по разным городам с разным качеством интернета и разными вычислительными возможностями серверов) - можно запускать модули на 
разных серверах по отдельности - с нашей архитектуре их синхронизация происходит автоматически путём выставления поля status, 
а транзакции и ключи не дают портить взаимоувязанность данных. 
Например, самый нагруженный модуль CodeDefinition.py можно запускать одновременно на нескольких серверах, причём в многоядерных системах можно 
каждый модуль поместить в контейнер (скажем docker), и запускать каждый экземпляр на отдельном ядре в нужном количестве.

----------------------------------------------------------------------------------------------------------------------------------------------

-- Выводы

В данной работе мы решили реальную задачу, которую я планирую запустить в "продакшн".
Мы использовали серверы баз данных MySQL и PostgreSQL, взаимодействовали с ними через консоли mysql и psql, графические оболочки SQL Manager и Dbeaver,
создавали БД, пользователей БД, таблицы, индексы, ключи, пользовательские типы данных, триггеры, хранимые процедуры\функции, транзакции и т.д.
Кол-во таблиц в нашей БД биллинга хоть и меньше требуемых 10, но мне кажется то что вместо одной БД у нас их несколько (+ БД CDR в MySQL на нескольких астерисках) 
компенсирует это. Можно было бы создать дополнительные таблицы для хранения каких-то доп.результатов, но в данной работе это непринципиально. 

Самое главное - мы работали с базами MySQL и PostgreSQL с помощью языка программирования Python3, отработали на нём основные приёмы:
- соединение\отсоединение БД
- отркрытие\закрытие транзакций
- создание объекта курсор для выполнения SQL запросов всех типов
- работа с переменными Python в SQL запросах и выборках  

Связка Python3 и серверов баз данных MySQL и PostgreSQL позволяет очень гибко работать с данными, приёмы и методы работы практически идентичны для 
большинства СУБД.

К сожалению не удалось запустить систему биллинга в реальную эксплуатацию по причине отъезда в отпуск: я думаю ещё потребуются какие-то доработки,
исправления и т.д., но в отладочном режиме система работает корректно - это главное!! :) 
